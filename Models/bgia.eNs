create model ia

# LOAD DATABASES

# ## LETTER FEATURE REPRESENTATION
create dataframe_for_reps features_db
features_db load Databases/letter_features_no_blank.eNd

# ## ORTHOGRAPHY, PHONOLOGY, FREQUENCIES
create dataframe_for_reps vocab
vocab load Databases/Vocab_files/ia.eNd

create dataframe_for_reps bigramf
bigramf load Databases/bigrams.eNd

# LEXICAL ROUTE LAYERS

# ## FEATURE LAYER
create representation feat_rep
feat_rep type blocked_representation
feat_rep set_element (features_db column_rep features)
feat_rep number 4
create iac_layer features
features represent feat_rep

#create pattern _mask
#_mask set feat_rep 1P/0 2P/0 3P/0 4A/0 5P/0 6P/0  7A/0 8A/0 9P/0 10P/0 11A/0 12P/0 13P/0 14P/0 1P/1 2P/1 3P/1 4A/1 5P/1 6P/1 7A/1 8A/1 9P/1 10P/1 11A/1 12P/1 13P/1 14P/1 1P/2 2P/2 3P/2 4A/2 5P/2 6P/2 7A/2 8A/2 9P/2 10P/2 11A/2 12P/2 13P/2 14P/2 1P/3 2P/3 3P/3 4A/3 5P/3 6P/3 7A/3 8A/3 9P/3 10P/3 11A/3 12P/3 13P/3 14P/3

# ## LETTER LAYER
create representation letter_rep
letter_rep type blocked_representation
letter_rep set_element (features_db column_rep letter)
letter_rep number 4

create iac_layer letters
letters represent letter_rep


# ## ORTHORAPHIC LEXICON (LAYER)
create iac_layer words
words represent (vocab column_rep Word)

# LEXICAL ROUTE CONNECTIONS

# ## FEATURE-LETTER
create connection flc
flc autoconnect features letters

# ## LETTER-ORTH
create string_split orth_str
# string_split is a conversion; it is a special conversion that generates the target representation
#   this target representation is (orth_str target)
#   (orth_str target) is a block_rep of (orth_str inner)
#   (orth_str inner) is a string_representation that is the single letters used in
#      (vocab column_rep Word string_representation)
orth_str set_blank "
orth_str set_source (vocab column_rep Word string_representation)
#   (vocab column_rep Word) == (vocab column_rep Word keyed_representation) which is a keyed_representation
#   (vocab column_rep Word string_representation) is the "dog" string_rep rather than the binary keyed_rep



create equiv_conversion lettersc
lettersc set_target (features_db column_rep letter string_representation)
lettersc set_source (orth_str inner)

create equiv_conversion lettersc2
lettersc2 set_source (features_db column_rep letter string_representation)
lettersc2 set_target (orth_str inner)


# this section is to ensure that we can use our special non-letter letters (ambiguous R/K stimulus: *)
((features_db column_rep features) find_conversion (orth_str inner)) set_auto 1
create parallel_conversion bananas
bananas set_source (orth_str get_target)
bananas set_target feat_rep

# these are the old solution to the problem of ensuring we can map from the string_rep to the feature
#    binary patterns; I suspect unnecessary with the above [UPDATE: CD -- tested script without the following, and conversions failed]
create parallel_conversion lopc
lopc set_source letter_rep
lopc set_target (orth_str get_target)
create parallel_conversion lopc2
lopc2 set_source (orth_str get_target)
lopc2 set_target letter_rep



#loglevel debug

create string_representation inter

create flatten_string_conversion flat
flat set_source (orth_str get_target)
flat set_target inter


create binary_layer thr_let
thr_let represent letter_rep

create string_layer string
string represent inter

create iac_layer bigrams
bigrams represent (bigramf column_rep bigram)

#create connection lsc
#lsc autoconnect letters string

create blocked_connection ltc
ltc set_autoconnect 0
ltc attach letters 
ltc set_inner_type best_above_threshold_connection
ltc set_target_inner_rep (features_db column_rep letter)
thr_let attach ltc

create connection tsc
tsc autoconnect thr_let string

create string_representation bgstring
create string_split bgsplit
bgsplit set_source bgstring
bgsplit set_chunk 2

create regex_conversion splat
splat set_source inter
splat set_target bgstring
splat add ^(.)(.)(.)(.) \2\3\4 \1\2\1\3\1\4
splat add ^(.)(.)(.) \2\3 \1\2\1\3
splat add ^(.)(.) \2 \1\2

create equiv_conversion bgc
bgc set_source (bgsplit get_target)
bgc set_target (bigramf column_rep bigram string_representation) 


create connection b1
b1 autoconnect string bigrams

create connection b4
b4 autoconnect bigrams words


#loc details

create connection olc
olc autoconnect words letters


# ## ORTH-ORTH
create connection lato
lato autoconnect words words

#create connection leto
#leto autoconnect letters letters

# OBSERVERS


# MODEL GROUP


ia define_input orthographic (vocab column_rep Word string_representation) features

words set_resting_level (vocab column_rep Rest)

create pattern rk_letter
rk_letter set (orth_str inner) *

create pattern rk_feats
rk_feats set (features_db column_rep features) 2P 3A 4A 7P 9P 10A 11A 12P 13A 14A

create pattern mask_letter
mask_letter set (orth_str inner) #

create pattern mask_feats
mask_feats set (features_db column_rep features) 1P 2P 3P 4A 5P 6P 7A 8A 9P 10P 11A 12P 13P 14P

create pattern blank_letter
blank_letter set (orth_str inner) _ 

create pattern blank_feats
blank_feats set (features_db column_rep features)

create pattern space_letter
space_letter set (orth_str inner) "

create pattern space_feats 1A 2A 3A 4A 5A 6A 7A 8A 9A 10A 11A 12A 13A 14A
space_feats set (features_db column_rep features)


create manual_conversion extras
extras set_auto_use 0
extras set_source (orth_str inner)
extras set_target (features_db column_rep features)
extras add rk_letter rk_feats
extras add mask_letter mask_feats
extras add blank_letter blank_feats
extras add space_letter space_feats

((features_db column_rep features) find_conversion (orth_str inner)) add_fallback extras
((features_db column_rep features) find_conversion (orth_str inner)) set_weight -1

